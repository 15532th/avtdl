import hashlib
import logging
import os
import urllib.parse
from pathlib import Path
from typing import List, Optional

from pydantic import AnyHttpUrl, ValidationError

from avtdl.core.download import download_file
from avtdl.core.interfaces import Record
from avtdl.core.request import HttpClient
from avtdl.core.utils import sanitize_filename


def is_url(maybe_url: str) -> bool:
    try:
        AnyHttpUrl(maybe_url)
        return True
    except ValidationError:
        return False


def find_file(path: Path) -> List[Path]:
    """given path to a file without extension, return list of existing files with exact path and name and any extension"""
    if not path.parent.exists():
        return []
    try:
        return [p for p in path.parent.iterdir() if p.stem == path.name]
    except OSError:
        return []


def find_free_suffix(path: Path, suffix_template: str) -> Path:
    """given path to possible existing file name without extension, find a free name
    generated by appending suffix_template to original filename, such that no file exists
    with that name and any extension. The suffix_template parameter must contain "{i}" exactly once"""
    if suffix_template.count("{i}") != 1:
        raise ValueError("The suffix_template must contain '{i}' exactly once.")

    base_name = path.name
    new_path = Path(path)

    i = 0
    while find_file(new_path):
        i += 1
        suffix = suffix_template.format(i=i)
        new_path = path.with_name(f"{base_name}{suffix}")
    return new_path


class FileCache:

    def __init__(self, cache_directory: Path, partial_file_suffix: str):
        self.cache_directory = cache_directory.resolve()
        self.partial_file_suffix = partial_file_suffix
        self.logger = logging.getLogger('cache')

    def filename_for(self, record: Record, url: str) -> Path:
        """generate path and name (without extension) for given url"""
        subdirectory = Path(urllib.parse.urlparse(url).netloc)
        url_hash = hashlib.md5(url.encode()).hexdigest().upper()
        name = sanitize_filename(f'{record.get_uid()} [{url_hash}]', collapse=True)
        name = Path(name)
        filename = self.cache_directory / subdirectory / name
        return filename

    def retrieve(self, record: Record, url: str) -> Optional[Path]:
        path = self.filename_for(record, url)
        file = self._find_file(path, url)
        return file

    async def store(self, logger: logging.Logger, client: HttpClient,
                    record: Record, url: str, reuse: bool = True) -> Optional[Path]:
        """download and store or find existing local copy of the url, return path to the local file.
        Use existing file if "reuse" option enabled, otherwise pick a new name and download anyway"""
        store_path = self.filename_for(record, url)
        file = self._find_file(store_path, url)
        if file and reuse:
            self.logger.debug(f'reusing stored file "{file}" for "{url}"')
            return file
        store_path = find_free_suffix(store_path, ' [{i}]')
        try:
            store_path.parent.mkdir(parents=True, exist_ok=True)
        except OSError as e:
            logger.warning(f'failed to create directory hierarchy "{store_path.parent}", skipping record {record!r}')
            return None
        return await self._download_file(logger, client, url, store_path)

    async def _download_file(self, logger: logging.Logger, client: HttpClient, url: str, path: Path) -> Optional[Path]:
        """download file from given url, store to path, return path if successful"""
        temp_path = path.with_name(path.name + self.partial_file_suffix)
        info = await download_file(url, temp_path, client.session, logger=logger)
        if info is None:
            return None
        final_path = temp_path.with_suffix(info.extension)
        try:
            logger.debug(f'moving "{temp_path}" to "{final_path}"')
            os.replace(temp_path, final_path)
            return final_path
        except Exception as e:
            message = f'failed to move file "{temp_path}" to desired location "{final_path}": {e}'
            logger.warning(message)
            return None

    def _find_file(self, path: Path, url: str) -> Optional[Path]:
        files = find_file(path)
        if len(files) == 1:
            file = files[0]
            self.logger.debug(f'url "{url} is stored at "{file}"')
            return file
        elif len(files) > 1:
            for file in files:
                if url.endswith(file.suffix):
                    self.logger.debug(f'url "{url} is stored at "{file}" (picked best match out of {len(files)})')
                    return file
            self.logger.warning(f'found multiple files suitable for url "{url}": {files}')
            return files[0]
        else:
            return None
